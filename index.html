<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ahanaf Runner  - The Chutiya Runner</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 5;
        }
        
        .stats-left, .stats-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px 18px;
            color: white;
            font-weight: 600;
            font-size: clamp(14px, 3vw, 20px);
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat-box.coins {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .stat-box.score {
            background: linear-gradient(135deg, rgba(0,212,255,0.4), rgba(0,100,200,0.4));
            border: 1px solid rgba(0, 212, 255, 0.4);
        }
        
        .stat-box.best {
            background: linear-gradient(135deg, rgba(255,107,107,0.4), rgba(200,50,50,0.4));
            border: 1px solid rgba(255, 107, 107, 0.4);
        }
        
        #powerupIndicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 5;
            pointer-events: none;
        }
        
        .powerup-badge {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: clamp(12px, 2.5vw, 16px);
            display: flex;
            align-items: center;
            gap: 8px;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        .powerup-badge.magnet {
            border: 2px solid #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }
        
        .powerup-badge.invincible {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            z-index: 20;
            padding: 20px;
            text-align: center;
        }
        
        .game-screen.hidden {
            display: none;
        }
        
        .game-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(36px, 10vw, 70px);
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #ff6b6b);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientMove 3s ease infinite;
            margin-bottom: 10px;
        }
        
        .game-subtitle {
            font-size: clamp(14px, 3vw, 22px);
            color: rgba(255,255,255,0.7);
            margin-bottom: 30px;
        }
        
        .btn {
            padding: clamp(12px, 3vw, 20px) clamp(40px, 10vw, 70px);
            font-size: clamp(18px, 4vw, 28px);
            font-family: 'Bangers', cursive;
            letter-spacing: 3px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }
        
        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }
        
        .btn:active {
            transform: scale(1.05);
        }
        
        .btn-start {
            background: linear-gradient(135deg, #6bcb77, #4d96ff);
            color: white;
            box-shadow: 0 8px 30px rgba(75, 150, 255, 0.5);
        }
        
        .btn-restart {
            background: linear-gradient(135deg, #ff6b6b, #ffd93d);
            color: white;
            box-shadow: 0 8px 30px rgba(255, 107, 107, 0.5);
        }
        
        .instructions {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 350px;
        }
        
        .instruction-item {
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: clamp(11px, 2.5vw, 14px);
            color: rgba(255,255,255,0.85);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .instruction-item span {
            font-size: clamp(16px, 4vw, 22px);
        }
        
        .final-stats {
            display: flex;
            gap: 20px;
            margin: 20px 0 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .final-stat {
            background: rgba(255,255,255,0.1);
            padding: 15px 30px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .final-stat-value {
            font-family: 'Bangers', cursive;
            font-size: clamp(28px, 7vw, 45px);
            color: #ffd93d;
        }
        
        .final-stat-label {
            font-size: clamp(10px, 2.5vw, 14px);
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .new-record {
            color: #6bcb77;
            font-size: clamp(14px, 3.5vw, 20px);
            margin-bottom: 15px;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes gradientMove {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }
        
        .shake {
            animation: shake 0.4s ease-in-out;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .loader {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #loading p {
            margin-top: 15px;
            color: rgba(255,255,255,0.7);
            font-size: 16px;
        }
        
        #loading.hidden {
            display: none;
        }

        /* Mobile controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 10;
            pointer-events: none;
        }

        .mobile-btn {
            width: clamp(50px, 12vw, 70px);
            height: clamp(50px, 12vw, 70px);
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 5vw, 28px);
            color: white;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        @media (min-width: 768px) {
            #mobileControls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="loading">
            <div class="loader"></div>
            <p>Loading Game...</p>
        </div>
        
        <div id="ui">
            <div class="stats-left">
                <div class="stat-box score">
                    <span>üèÉ</span>
                    <span id="score">0</span>
                </div>
                <div class="stat-box coins">
                    <span>ü™ô</span>
                    <span id="coins">0</span>
                </div>
            </div>
            <div class="stats-right">
                <div class="stat-box best">
                    <span>üëë</span>
                    <span id="highScore">0</span>
                </div>
            </div>
        </div>
        
        <div id="powerupIndicator"></div>

        <div id="mobileControls">
            <button class="mobile-btn" id="btnLeft">‚¨ÖÔ∏è</button>
            <button class="mobile-btn" id="btnUp">‚¨ÜÔ∏è</button>
            <button class="mobile-btn" id="btnDown">‚¨áÔ∏è</button>
            <button class="mobile-btn" id="btnRight">‚û°Ô∏è</button>
        </div>
        
        <div class="game-screen" id="startScreen">
            <div class="game-title">üèÉ SUBWAY RUSH üöá</div>
            <div class="game-subtitle">3D Endless Runner</div>
            <button class="btn btn-start" id="startBtn">‚ñ∂ PLAY</button>
            <div class="instructions">
                <div class="instruction-item"><span>‚¨ÖÔ∏è‚û°Ô∏è</span> Switch Lanes</div>
                <div class="instruction-item"><span>‚¨ÜÔ∏è</span> Jump</div>
                <div class="instruction-item"><span>‚¨áÔ∏è</span> Slide</div>
                <div class="instruction-item"><span>üì±</span> Swipe/Buttons</div>
            </div>
        </div>
        
        <div class="game-screen hidden" id="gameOverScreen">
            <div class="game-title">üí• GAME OVER üí•</div>
            <div class="new-record hidden" id="newRecord">üéâ NEW HIGH SCORE! üéâ</div>
            <div class="final-stats">
                <div class="final-stat">
                    <div class="final-stat-value" id="finalScore">0</div>
                    <div class="final-stat-label">Score</div>
                </div>
                <div class="final-stat">
                    <div class="final-stat-value" id="finalCoins">0</div>
                    <div class="final-stat-label">Coins</div>
                </div>
            </div>
            <button class="btn btn-restart" id="restartBtn">üîÑ RETRY</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, clock;
        let player;
        let obstacles = [];
        let coins = [];
        let powerups = [];
        let particles = [];
        let tracks = [];
        let buildings = [];
        
        // Game state
        let gameRunning = false;
        let score = 0;
        let coinCount = 0;
        let highScore = parseInt(localStorage.getItem('subwayHighScore3D')) || 0;
        let speed = 0.35;
        let maxSpeed = 0.9;
        let frameCount = 0;
        
        // Player state
        const playerState = {
            lane: 1,
            targetLane: 1,
            jumping: false,
            sliding: false,
            jumpVelocity: 0,
            slideTimer: 0,
            invincible: false,
            invincibleTimer: 0,
            magnetActive: false,
            magnetTimer: 0,
            x: 0,
            y: 0
        };
        
        // Lane positions
        const laneWidth = 2.8;
        const lanes = [-laneWidth, 0, laneWidth];
        
        // Colors
        const trainColors = [0xe74c3c, 0x3498db, 0x2ecc71, 0x9b59b6, 0xf39c12, 0x1abc9c];
        
        // Initialize
        function init() {
            clock = new THREE.Clock();
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);
            
            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 1, -10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            setupLighting();
            
            // Create world
            createSky();
            createGround();
            createBuildings();
            createPlayer();
            
            // Setup input
            setupInput();
            
            // Update UI
            document.getElementById('highScore').textContent = highScore.toLocaleString();
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 300);
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            
            // Start loop
            animate();
        }
        
        function setupLighting() {
            // Ambient
            const ambient = new THREE.AmbientLight(0x6688cc, 0.6);
            scene.add(ambient);
            
            // Directional (moon)
            const dirLight = new THREE.DirectionalLight(0xaaccff, 1);
            dirLight.position.set(-5, 15, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);
            
            // Hemisphere
            const hemi = new THREE.HemisphereLight(0x88aaff, 0x444422, 0.5);
            scene.add(hemi);
        }
        
        function createSky() {
            // Stars
            const starsGeo = new THREE.BufferGeometry();
            const starPositions = [];
            for (let i = 0; i < 500; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = Math.random() * 80 + 20;
                const z = (Math.random() - 0.5) * 200 - 50;
                starPositions.push(x, y, z);
            }
            starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);
            
            // Moon
            const moonGeo = new THREE.SphereGeometry(4, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            const moon = new THREE.Mesh(moonGeo, moonMat);
            moon.position.set(-25, 35, -80);
            scene.add(moon);
        }
        
        function createGround() {
            // Create track sections
            for (let i = 0; i < 15; i++) {
                createTrackSection(-i * 30);
            }
        }
        
        function createTrackSection(z) {
            const group = new THREE.Group();
            group.position.z = z;
            
            // Main ground
            const groundGeo = new THREE.BoxGeometry(15, 0.5, 30);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a4a, 
                roughness: 0.9 
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.position.y = -0.25;
            ground.receiveShadow = true;
            group.add(ground);
            
            // Rails for each lane
            const railGeo = new THREE.BoxGeometry(0.1, 0.1, 30);
            const railMat = new THREE.MeshStandardMaterial({ 
                color: 0x888899, 
                metalness: 0.8, 
                roughness: 0.3 
            });
            
            for (let lane = 0; lane < 3; lane++) {
                const leftRail = new THREE.Mesh(railGeo, railMat);
                leftRail.position.set(lanes[lane] - 0.9, 0.05, 0);
                group.add(leftRail);
                
                const rightRail = new THREE.Mesh(railGeo, railMat);
                rightRail.position.set(lanes[lane] + 0.9, 0.05, 0);
                group.add(rightRail);
            }
            
            // Lane markers
            const markerGeo = new THREE.BoxGeometry(0.15, 0.02, 30);
            const markerMat = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.5 
            });
            
            const marker1 = new THREE.Mesh(markerGeo, markerMat);
            marker1.position.set(-laneWidth / 2 - 0.5, 0.02, 0);
            group.add(marker1);
            
            const marker2 = new THREE.Mesh(markerGeo, markerMat);
            marker2.position.set(laneWidth / 2 + 0.5, 0.02, 0);
            group.add(marker2);
            
            // Sleepers
            const sleeperGeo = new THREE.BoxGeometry(14, 0.1, 0.5);
            const sleeperMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a });
            for (let i = 0; i < 10; i++) {
                const sleeper = new THREE.Mesh(sleeperGeo, sleeperMat);
                sleeper.position.set(0, -0.05, -15 + i * 3);
                sleeper.receiveShadow = true;
                group.add(sleeper);
            }
            
            scene.add(group);
            tracks.push(group);
        }
        
        function createBuildings() {
            const colors = [0x1a1a3a, 0x2a2a4a, 0x1a2a4a, 0x2a1a4a];
            
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < 20; i++) {
                    const w = 3 + Math.random() * 5;
                    const h = 10 + Math.random() * 30;
                    const d = 4 + Math.random() * 6;
                    
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mat = new THREE.MeshStandardMaterial({
                        color: colors[Math.floor(Math.random() * colors.length)],
                        roughness: 0.8
                    });
                    
                    const building = new THREE.Mesh(geo, mat);
                    building.position.set(
                        side * (12 + Math.random() * 8),
                        h / 2,
                        -i * 20 - Math.random() * 15
                    );
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    // Windows
                    const windowGeo = new THREE.PlaneGeometry(0.5, 0.8);
                    const windowMatLit = new THREE.MeshBasicMaterial({ color: 0xffee77 });
                    const windowMatDark = new THREE.MeshBasicMaterial({ color: 0x222244 });
                    
                    const cols = Math.floor(w / 1.5);
                    const rows = Math.floor(h / 2.5);
                    
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const win = new THREE.Mesh(
                                windowGeo, 
                                Math.random() > 0.35 ? windowMatLit : windowMatDark
                            );
                            win.position.set(
                                -w/2 + 1 + c * 1.5,
                                -h/2 + 2 + r * 2.5,
                                d/2 + 0.01
                            );
                            building.add(win);
                        }
                    }
                    
                    scene.add(building);
                    buildings.push(building);
                }
            }
        }
        
        function createPlayer() {
            player = new THREE.Group();
            
            // Body (using cylinder instead of capsule for compatibility)
            const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.2, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x00aaff, 
                roughness: 0.5 
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.1;
            body.castShadow = true;
            player.add(body);
            player.body = body;
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.32, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2;
            head.castShadow = true;
            player.add(head);
            player.head = head;
            
            // Cap
            const capGeo = new THREE.CylinderGeometry(0.35, 0.3, 0.2, 16);
            const capMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 2.25;
            player.add(cap);
            
            // Cap brim
            const brimGeo = new THREE.BoxGeometry(0.45, 0.05, 0.3);
            const brim = new THREE.Mesh(brimGeo, capMat);
            brim.position.set(0, 2.15, 0.3);
            player.add(brim);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x0088cc });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.5, 1.3, 0);
            leftArm.castShadow = true;
            player.add(leftArm);
            player.leftArm = leftArm;
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.5, 1.3, 0);
            rightArm.castShadow = true;
            player.add(rightArm);
            player.rightArm = rightArm;
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 8);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2980b9 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.18, 0.35, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.18, 0.35, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.rightLeg = rightLeg;
            
            // Shoes
            const shoeGeo = new THREE.BoxGeometry(0.22, 0.12, 0.35);
            const shoeMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
            
            const leftShoe = new THREE.Mesh(shoeGeo, shoeMat);
            leftShoe.position.set(-0.18, 0.06, 0.05);
            player.add(leftShoe);
            player.leftShoe = leftShoe;
            
            const rightShoe = new THREE.Mesh(shoeGeo, shoeMat);
            rightShoe.position.set(0.18, 0.06, 0.05);
            player.add(rightShoe);
            player.rightShoe = rightShoe;
            
            // Shield (invincibility)
            const shieldGeo = new THREE.SphereGeometry(1.3, 32, 32);
            const shieldMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0,
                side: THREE.DoubleSide
            });
            const shield = new THREE.Mesh(shieldGeo, shieldMat);
            shield.position.y = 1.1;
            player.add(shield);
            player.shield = shield;
            
            player.position.set(0, 0, 0);
            scene.add(player);
        }
        
        function setupInput() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                    e.preventDefault();
                    handleInput(e.code);
                }
            });
            
            // Touch swipe
            let touchStartX = 0;
            let touchStartY = 0;
            
            const gameCanvas = document.getElementById('gameCanvas');
            
            gameCanvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            gameCanvas.addEventListener('touchend', (e) => {
                const dx = e.changedTouches[0].clientX - touchStartX;
                const dy = e.changedTouches[0].clientY - touchStartY;
                
                if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 40) {
                    handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
                } else if (Math.abs(dy) > 40) {
                    handleInput(dy < 0 ? 'ArrowUp' : 'ArrowDown');
                }
            }, { passive: true });
            
            // Mobile buttons
            document.getElementById('btnLeft').addEventListener('click', () => handleInput('ArrowLeft'));
            document.getElementById('btnRight').addEventListener('click', () => handleInput('ArrowRight'));
            document.getElementById('btnUp').addEventListener('click', () => handleInput('ArrowUp'));
            document.getElementById('btnDown').addEventListener('click', () => handleInput('ArrowDown'));
            
            // Touch for mobile buttons
            document.getElementById('btnLeft').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowLeft'); });
            document.getElementById('btnRight').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowRight'); });
            document.getElementById('btnUp').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowUp'); });
            document.getElementById('btnDown').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowDown'); });
            
            // Game buttons
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', startGame);
        }
        
        function handleInput(code) {
            if (!gameRunning) return;
            
            if ((code === 'ArrowLeft' || code === 'KeyA') && playerState.targetLane > 0) {
                playerState.targetLane--;
                createParticles(player.position.x, 1, player.position.z, 0x00d4ff, 8);
            }
            if ((code === 'ArrowRight' || code === 'KeyD') && playerState.targetLane < 2) {
                playerState.targetLane++;
                createParticles(player.position.x, 1, player.position.z, 0x00d4ff, 8);
            }
            if ((code === 'ArrowUp' || code === 'KeyW' || code === 'Space') && !playerState.jumping && !playerState.sliding) {
                playerState.jumping = true;
                playerState.jumpVelocity = 0.45;
                createParticles(player.position.x, 0.5, player.position.z, 0x00ff88, 12);
            }
            if ((code === 'ArrowDown' || code === 'KeyS') && !playerState.jumping && !playerState.sliding) {
                playerState.sliding = true;
                playerState.slideTimer = 45;
                createParticles(player.position.x, 0.5, player.position.z, 0xffd700, 8);
            }
        }
        
        function createParticles(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(0.08, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.set(x, y, z);
                particle.velocity = {
                    x: (Math.random() - 0.5) * 0.3,
                    y: Math.random() * 0.2 + 0.1,
                    z: (Math.random() - 0.5) * 0.3
                };
                particle.life = 1;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function spawnObstacle() {
            const lane = Math.floor(Math.random() * 3);
            const types = ['train', 'barrier', 'tallBarrier'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            // Check min distance
            for (const obs of obstacles) {
                if (obs.position.z > -50) return;
            }
            
            let obstacle;
            
            if (type === 'train') {
                obstacle = createTrain();
                obstacle.userData.type = 'train';
                obstacle.userData.height = 3.5;
            } else if (type === 'barrier') {
                obstacle = createBarrier();
                obstacle.userData.type = 'barrier';
                obstacle.userData.height = 1;
            } else {
                obstacle = createTallBarrier();
                obstacle.userData.type = 'tallBarrier';
                obstacle.userData.height = 4;
            }
            
            obstacle.position.set(lanes[lane], 0, -120);
            obstacle.userData.lane = lane;
            obstacle.userData.passed = false;
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function createTrain() {
            const train = new THREE.Group();
            const color = trainColors[Math.floor(Math.random() * trainColors.length)];
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(2.2, 3.5, 7);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.4, 
                metalness: 0.4 
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.75;
            body.castShadow = true;
            train.add(body);
            
            // Roof
            const roofGeo = new THREE.BoxGeometry(2.3, 0.25, 7.1);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3.6;
            train.add(roof);
            
            // Windows
            const winGeo = new THREE.PlaneGeometry(0.6, 1.1);
            const winMat = new THREE.MeshBasicMaterial({ color: 0xaaddff });
            
            for (let i = 0; i < 3; i++) {
                const winL = new THREE.Mesh(winGeo, winMat);
                winL.position.set(-1.11, 2.2, -2 + i * 2);
                winL.rotation.y = -Math.PI / 2;
                train.add(winL);
                
                const winR = new THREE.Mesh(winGeo, winMat);
                winR.position.set(1.11, 2.2, -2 + i * 2);
                winR.rotation.y = Math.PI / 2;
                train.add(winR);
            }
            
            // Front window
            const frontWin = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 1.2), winMat);
            frontWin.position.set(0, 2.5, 3.51);
            train.add(frontWin);
            
            // Headlights
            const lightGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            
            const lightL = new THREE.Mesh(lightGeo, lightMat);
            lightL.position.set(-0.7, 0.8, 3.5);
            train.add(lightL);
            
            const lightR = new THREE.Mesh(lightGeo, lightMat);
            lightR.position.set(0.7, 0.8, 3.5);
            train.add(lightR);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.15, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
            
            [-0.9, 0.9].forEach(x => {
                [-2.5, 2.5].forEach(z => {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(x, 0.3, z);
                    train.add(wheel);
                });
            });
            
            return train;
        }
        
        function createBarrier() {
            const barrier = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(2.8, 1, 1.2);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            barrier.add(body);
            
            // Stripes
            const stripeGeo = new THREE.BoxGeometry(0.25, 0.85, 1.22);
            const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            
            for (let i = 0; i < 4; i++) {
                const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                stripe.position.set(-1.1 + i * 0.7, 0.5, 0);
                barrier.add(stripe);
            }
            
            return barrier;
        }
        
        function createTallBarrier() {
            const barrier = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(2.4, 4, 1.2);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc3333 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 2;
            body.castShadow = true;
            barrier.add(body);
            
            // X pattern
            const crossGeo = new THREE.BoxGeometry(0.12, 3.2, 0.1);
            const crossMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            
            const cross1 = new THREE.Mesh(crossGeo, crossMat);
            cross1.position.set(0, 2, 0.61);
            cross1.rotation.z = Math.PI / 4;
            barrier.add(cross1);
            
            const cross2 = new THREE.Mesh(crossGeo, crossMat);
            cross2.position.set(0, 2, 0.61);
            cross2.rotation.z = -Math.PI / 4;
            barrier.add(cross2);
            
            return barrier;
        }
        
        function spawnCoin() {
            const lane = Math.floor(Math.random() * 3);
            const count = 3 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < count; i++) {
                const coin = createCoin();
                coin.position.set(lanes[lane], 1.5, -90 - i * 3.5);
                coin.userData.collected = false;
                coin.userData.floatOffset = Math.random() * Math.PI * 2;
                scene.add(coin);
                coins.push(coin);
            }
        }
        
        function createCoin() {
            const coin = new THREE.Group();
            
            const geo = new THREE.CylinderGeometry(0.45, 0.45, 0.12, 24);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.2, 
                metalness: 0.9,
                emissive: 0xaa7700,
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2;
            coin.add(mesh);
            
            // Glow
            const glowGeo = new THREE.SphereGeometry(0.55, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffd700, 
                transparent: true, 
                opacity: 0.25 
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            coin.add(glow);
            
            return coin;
        }
        
        function spawnPowerup() {
            if (Math.random() < 0.008 && powerups.length === 0) {
                const lane = Math.floor(Math.random() * 3);
                const types = ['magnet', 'invincible'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                const powerup = createPowerup(type);
                powerup.position.set(lanes[lane], 2.5, -100);
                powerup.userData.type = type;
                scene.add(powerup);
                powerups.push(powerup);
            }
        }
        
        function createPowerup(type) {
            const powerup = new THREE.Group();
            const color = type === 'magnet' ? 0xff00ff : 0x00ffff;
            
            const geo = new THREE.OctahedronGeometry(0.65);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.2, 
                metalness: 0.8,
                emissive: color,
                emissiveIntensity: 0.4
            });
            const mesh = new THREE.Mesh(geo, mat);
            powerup.add(mesh);
            
            const glowGeo = new THREE.SphereGeometry(1, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.25 
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            powerup.add(glow);
            powerup.glow = glow;
            
            return powerup;
        }
        
        function updatePlayer() {
            const time = clock.getElapsedTime();
            
            // Lane movement
            const targetX = lanes[playerState.targetLane];
            playerState.x += (targetX - playerState.x) * 0.18;
            player.position.x = playerState.x;
            
            // Jumping
            if (playerState.jumping) {
                playerState.y += playerState.jumpVelocity;
                playerState.jumpVelocity -= 0.025;
                
                if (playerState.y <= 0) {
                    playerState.y = 0;
                    playerState.jumping = false;
                    playerState.jumpVelocity = 0;
                    createParticles(player.position.x, 0.3, player.position.z, 0x666666, 6);
                }
            }
            player.position.y = playerState.y;
            
            // Sliding
            if (playerState.sliding) {
                playerState.slideTimer--;
                if (playerState.slideTimer <= 0) {
                    playerState.sliding = false;
                }
            }
            
            // Visual updates
            const targetScale = playerState.sliding ? 0.35 : 1;
            player.body.scale.y = THREE.MathUtils.lerp(player.body.scale.y, targetScale, 0.25);
            player.body.position.y = playerState.sliding ? 0.5 : 1.1;
            player.head.visible = !playerState.sliding;
            
            // Animate limbs
            const runSpeed = playerState.jumping ? 0 : 10;
            player.leftLeg.rotation.x = Math.sin(time * runSpeed) * 0.7;
            player.rightLeg.rotation.x = -Math.sin(time * runSpeed) * 0.7;
            player.leftArm.rotation.x = -Math.sin(time * runSpeed) * 0.5;
            player.rightArm.rotation.x = Math.sin(time * runSpeed) * 0.5;
            
            player.leftShoe.position.z = 0.05 + Math.sin(time * runSpeed) * 0.25;
            player.rightShoe.position.z = 0.05 - Math.sin(time * runSpeed) * 0.25;
            
            // Invincibility
            if (playerState.invincible) {
                playerState.invincibleTimer--;
                player.shield.material.opacity = 0.25 + Math.sin(time * 12) * 0.1;
                if (playerState.invincibleTimer <= 0) {
                    playerState.invincible = false;
                    player.shield.material.opacity = 0;
                }
            }
            
            // Magnet
            if (playerState.magnetActive) {
                playerState.magnetTimer--;
                if (playerState.magnetTimer <= 0) {
                    playerState.magnetActive = false;
                }
            }
            
            updatePowerupIndicator();
        }
        
        function updateObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.position.z += speed;
                
                // Simple collision detection
                const dx = Math.abs(player.position.x - obs.position.x);
                const dz = Math.abs(player.position.z - obs.position.z);
                const playerHeight = playerState.sliding ? 0.5 : 2.2;
                const playerY = playerState.y + playerHeight / 2;
                
                if (dx < 1.2 && dz < 2.5) {
                    const obsType = obs.userData.type;
                    const obsHeight = obs.userData.height;
                    
                    let collision = false;
                    
                    if (obsType === 'barrier') {
                        // Can jump over
                        if (playerState.y < 1.2) {
                            collision = true;
                        }
                    } else if (obsType === 'tallBarrier') {
                        // Can slide under
                        if (!playerState.sliding) {
                            collision = true;
                        }
                    } else if (obsType === 'train') {
                        // Must avoid
                        collision = true;
                    }
                    
                    if (collision && !playerState.invincible) {
                        gameOver();
                        return;
                    }
                }
                
                // Score for passing
                if (!obs.userData.passed && obs.position.z > 2) {
                    obs.userData.passed = true;
                    score += 50;
                }
                
                // Remove
                if (obs.position.z > 15) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }
        }
        
        function updateCoins() {
            const time = clock.getElapsedTime();
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.position.z += speed;
                coin.rotation.y += 0.06;
                coin.position.y = 1.5 + Math.sin(time * 4 + coin.userData.floatOffset) * 0.25;
                
                // Magnet effect
                if (playerState.magnetActive) {
                    const dx = player.position.x - coin.position.x;
                    const dy = (player.position.y + 1) - coin.position.y;
                    const dz = player.position.z - coin.position.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < 18) {
                        coin.position.x += dx * 0.12;
                        coin.position.y += dy * 0.12;
                        coin.position.z += dz * 0.12;
                    }
                }
                
                // Collection
                const dist = player.position.distanceTo(coin.position);
                if (dist < 1.8 && !coin.userData.collected) {
                    coin.userData.collected = true;
                    coinCount++;
                    score += 25;
                    createParticles(coin.position.x, coin.position.y, coin.position.z, 0xffd700, 15);
                    scene.remove(coin);
                    coins.splice(i, 1);
                    continue;
                }
                
                if (coin.position.z > 15) {
                    scene.remove(coin);
                    coins.splice(i, 1);
                }
            }
        }
        
        function updatePowerups() {
            const time = clock.getElapsedTime();
            
            for (let i = powerups.length - 1; i >= 0; i--) {
                const pw = powerups[i];
                pw.position.z += speed;
                pw.rotation.y += 0.04;
                pw.rotation.x = Math.sin(time * 2.5) * 0.4;
                
                if (pw.glow) {
                    pw.glow.scale.setScalar(1 + Math.sin(time * 6) * 0.25);
                }
                
                // Collection
                const dist = player.position.distanceTo(pw.position);
                if (dist < 2) {
                    if (pw.userData.type === 'magnet') {
                        playerState.magnetActive = true;
                        playerState.magnetTimer = 400;
                    } else {
                        playerState.invincible = true;
                        playerState.invincibleTimer = 350;
                    }
                    createParticles(pw.position.x, pw.position.y, pw.position.z, 0x00ff88, 25);
                    scene.remove(pw);
                    powerups.splice(i, 1);
                    continue;
                }
                
                if (pw.position.z > 15) {
                    scene.remove(pw);
                    powerups.splice(i, 1);
                }
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                
                p.position.x += p.velocity.x;
                p.position.y += p.velocity.y;
                p.position.z += p.velocity.z;
                p.velocity.y -= 0.012;
                
                p.material.opacity = p.life;
                
                if (p.life <= 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }
        
        function updateTracks() {
            tracks.forEach(track => {
                track.position.z += speed;
                if (track.position.z > 30) {
                    track.position.z -= 450;
                }
            });
        }
        
        function updatePowerupIndicator() {
            const indicator = document.getElementById('powerupIndicator');
            let html = '';
            
            if (playerState.invincible) {
                const sec = Math.ceil(playerState.invincibleTimer / 60);
                html += `<div class="powerup-badge invincible">üõ°Ô∏è SHIELD ${sec}s</div>`;
            }
            if (playerState.magnetActive) {
                const sec = Math.ceil(playerState.magnetTimer / 60);
                html += `<div class="powerup-badge magnet">üß≤ MAGNET ${sec}s</div>`;
            }
            
            indicator.innerHTML = html;
        }
        
        function updateCamera() {
            const targetY = 5 + (speed - 0.35) * 3;
            const targetZ = 10 + (speed - 0.35) * 4;
            camera.position.y += (targetY - camera.position.y) * 0.03;
            camera.position.z += (targetZ - camera.position.z) * 0.03;
            camera.position.x += (player.position.x * 0.2 - camera.position.x) * 0.05;
            camera.lookAt(player.position.x * 0.4, 1.5, -15);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameRunning) {
                frameCount++;
                
                // Speed increase
                speed = Math.min(maxSpeed, 0.35 + score / 2500);
                
                // Score
                score += Math.floor(speed * 3);
                
                // Spawning
                if (frameCount % 60 === 0) spawnObstacle();
                if (frameCount % 90 === 0) spawnCoin();
                spawnPowerup();
                
                // Updates
                updatePlayer();
                updateObstacles();
                updateCoins();
                updatePowerups();
                updateParticles();
                updateTracks();
                updateCamera();
                
                // UI
                document.getElementById('score').textContent = score.toLocaleString();
                document.getElementById('coins').textContent = coinCount;
                document.getElementById('highScore').textContent = Math.max(score, highScore).toLocaleString();
            }
            
            renderer.render(scene, camera);
        }
        
        function startGame() {
            gameRunning = true;
            score = 0;
            coinCount = 0;
            speed = 0.35;
            frameCount = 0;
            
            // Clear objects
            obstacles.forEach(o => scene.remove(o));
            coins.forEach(c => scene.remove(c));
            powerups.forEach(p => scene.remove(p));
            particles.forEach(p => { scene.remove(p); p.geometry.dispose(); p.material.dispose(); });
            
            obstacles = [];
            coins = [];
            powerups = [];
            particles = [];
            
            // Reset player
            playerState.lane = 1;
            playerState.targetLane = 1;
            playerState.x = 0;
            playerState.y = 0;
            playerState.jumping = false;
            playerState.sliding = false;
            playerState.invincible = false;
            playerState.magnetActive = false;
            playerState.invincibleTimer = 0;
            playerState.magnetTimer = 0;
            
            player.position.set(0, 0, 0);
            player.shield.material.opacity = 0;
            player.body.scale.y = 1;
            
            // Reset tracks
            tracks.forEach((track, i) => {
                track.position.z = -i * 30;
            });
            
            // Hide screens
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
        }
        
        function gameOver() {
            gameRunning = false;
            
            // Particles
            for (let i = 0; i < 4; i++) {
                createParticles(player.position.x, 1.5, player.position.z, 0xff6b6b, 20);
                createParticles(player.position.x, 1, player.position.z, 0xffd93d, 15);
            }
            
            const isNewRecord = score > highScore;
            if (isNewRecord) {
                highScore = score;
                localStorage.setItem('subwayHighScore3D', highScore);
            }
            
            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('finalCoins').textContent = coinCount;
            document.getElementById('newRecord').classList.toggle('hidden', !isNewRecord);
            
            document.getElementById('gameContainer').classList.add('shake');
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('shake');
            }, 400);
            
            setTimeout(() => {
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }, 500);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Start
        init();
    </script>
</body>
</html>
